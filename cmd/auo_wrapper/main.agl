package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"go/types"
	"os"
	"path/filepath"
	"runtime"
)

func main() {
	goroot := runtime.GOROOT()
	fileName := "request.go"
	fnName := "NewRequest"
	filePath := filepath.Join(goroot, "src", "net", "http", fileName)
	src := os.ReadFile(filePath)!
	fset := token.NewFileSet()
	node := parser.ParseFile(fset, fileName, src, parser.AllErrors)!
	conf := types.Config{Importer: nil}
	info := &types.Info{Defs: make(map[*ast.Ident]types.Object)}
	conf.Check("", fset, []*ast.File{node}, info)
	for _, decl := range node.Decls {
	 	switch d := decl.(type) {
	 	case *ast.FuncDecl:
			if d.Name.Name == fnName && d.Recv == nil {
	 			wrapFn(fset, d)
	 		}
	 	}
	}
}

func wrapFn(fset *token.FileSet, decl *ast.FuncDecl) {
	env := map[string]string{
		"io.Reader": "interface",
	}
	out := "func " + decl.Name.Name + "("
 	var paramsArr []string
 	for _, param := range decl.Type.Params.List {
		var parts []string
		
		names := param.Names.Map({ $0.Name }).Joined(", ")
		parts = append(parts, names)
		
		var typeName string
 		switch param1 := param.Type.(type) {
		case *ast.SelectorExpr:
			typeName = param1.X.(*ast.Ident)?.Name + "." + param1.Sel.Name
 		case *ast.Ident:
 			typeName = param1.Name
 		}
		if env[typeName] == "interface" { // interfaces can be "nil", we use Option instead
			typeName += "?"
		}
		parts = append(parts, typeName)
		
		paramsArr = append(paramsArr, parts.Joined(" "))
 	}
	out += paramsArr.Joined(", ") + ")"
	if decl.Type.Results != nil {
		if decl.Type.Results.List.Last()?.Type.(*ast.Ident)?.Name == "error" {
			out += "!"
		}
 	}
	out += " {\n"
	out += "\t" + decl.Name.Name + "()\n"
	out += "}\n"
	fmt.Println(out)
}
