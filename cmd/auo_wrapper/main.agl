package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"go/types"
	"os"
	"path/filepath"
	"runtime"
	"strings"
	"reflect"
)

func main() {
	goroot := runtime.GOROOT()
	fileName := "request.go"
	fnName := "NewRequest"
	filePath := filepath.Join(goroot, "src", "net", "http", fileName)
	src := os.ReadFile(filePath)!
	fset := token.NewFileSet()
	node := parser.ParseFile(fset, fileName, src, parser.AllErrors)!
	conf := types.Config{Importer: nil}
	info := &types.Info{Defs: make(map[*ast.Ident]types.Object)}
	conf.Check("", fset, []*ast.File{node}, info)
	for _, decl := range node.Decls {
	 	switch d := decl.(type) {
	 	case *ast.FuncDecl:
			if d.Name.Name == fnName && d.Recv == nil {
	 			wrapFn(fset, d)
	 		}
	 	}
	}
}

func astToStr(n *ast.Field) string {
	var out string
	switch param := n.Type.(type) {
	case *ast.SelectorExpr:
		out = param.X.(*ast.Ident)?.Name + "." + param.Sel.Name
	case *ast.Ident:
		out = param.Name
	case *ast.StarExpr:
		out = "*"
	default:
		panic(fmt.Sprintf("%v", reflect.TypeOf(n.Type)))
	}
	return out
}

func wrapFn(fset *token.FileSet, decl *ast.FuncDecl) {
	env := map[string]string{
		"io.Reader": "interface",
	}
	
	var sb strings.Builder

 	var paramsArr []string
 	for _, param := range decl.Type.Params.List {
		var parts []string
		
		names := param.Names.Map({ $0.Name }).Joined(", ")
		parts.Push(names)
		
		typeName := astToStr(param)
		if env[typeName] == "interface" { // interfaces can be "nil", we use Option instead
			typeName = "Option[" + typeName + "]"
		}
		parts.Push(typeName)

		paramsArr.Push(parts.Joined(" "))
 	}
	
	fnName := decl.Name.Name
	paramsStr := paramsArr.Joined(", ")
	
	var resultStr string
	if decl.Type.Results != nil {
		results := decl.Type.Results.List
		var arr []string
		for _, res := range results {
			arr.Push(astToStr(res))
		}
		last := arr.Last()?
		lastIsErr := last == "error"
		if lastIsErr {
			arr.Pop()
		}
		if arr.Len() == 0 {
			resultStr = "AglVoid"
		} else {
			resultStr = arr.Joined(", ")
			if arr.Len() > 1 { // more than 1 value, return a Tuple
				resultStr = "(" + resultStr + ")"
			}
		}
		if lastIsErr {
			resultStr = "Result[" + resultStr + "]"
		}
		resultStr = " " + resultStr
 	}

	sb.WriteString("func " + fnName + "(" + paramsStr + ")" + resultStr + " {\n")
	sb.WriteString("\t" + fnName + "()\n")
	sb.WriteString("}\n")
	fmt.Println(sb.String())
}
