package main

import (
    "agl1/os"
    "fmt"
)

var mut secrets []int

func getNext(mut secret *int) {
    *secret ^= *secret << 6 & 0xFFFFFF
    *secret ^= *secret >> 5 & 0xFFFFFF
    *secret ^= *secret << 11 & 0xFFFFFF
}

func part1() {
    mut res := 0
    for secret in secrets {
        mut secret1 := secret
        for _ in 0..2000 {
            getNext(&mut secret1)
        }
        res += secret1
    }
    fmt.Println(res)
}


type S struct {
    a, b, c, d int
}

func part2() {
    mut cache := make([]map[S]int, 0)
    for secret1 in secrets {
        mut secretCache := make(map[S]int)
        mut secret := secret1
        mut prev := secret % 10
        mut arr := []int{0, 0, 0, 0}
        mut p := 0
        for i in 1..=2000 {
            getNext(&mut secret)
            price := secret % 10
            diff := price - prev
            arr[p] = diff
            if i >= 4 {
                key := S{a: arr[(p+0)%4], b: arr[(p+1)%4], c: arr[(p+2)%4], d: arr[(p+3)%4]}
                if !secretCache.ContainsKey(key) {
                    secretCache[key] = price
                }
            }
            p = (p + 1) % 4
            prev = price
        }
        cache.Push(secretCache)
    }

    keys := cache.Reduce(into: set[S]{}, { $0.FormUnion($1.Keys()) })
    res := keys.Map(|key| { cache.Reduce(0, { $0 + $1.Get(key).UnwrapOrDefault() }) }).Max()?
    fmt.Println(res)
}

func main() {
    fileContent := string(os.ReadFile("examples/adventOfCode2024/day22/data.txt")!)
    secrets = fileContent.Lines().Map({ $0.Int()? })
    part1()
    part2()
}