package main

import "agl1/os"

var mut data [][]string
var mut width int
var mut height int
var directions = [](int, int){(-1, 0), (0, -1), (1, 0), (0, 1)}

func dfs(id string, pos (int, int), mut seen set[(int, int)], mut sides set[((int, int), (int, int))]) set[(int, int)] {
    if !seen.Insert(pos) {
        return set[(int, int)]{}
    }
    mut region := set[(int, int)]{pos}
    for dir in directions {
        np := (pos.0 + dir.0, pos.1 + dir.1)
        if np.0 < 0 || np.0 >= width || np.1 < 0 || np.1 >= height || data[np.1][np.0] != id {
            sides.Insert((dir, np))
            continue
        }
        nregion := dfs(id, np, mut seen, mut sides)
        region.FormUnion(nregion)
    }
    return region
}

func part1() {
    mut res := 0
    mut seen := set[(int, int)]{}
    for y in data.Indices() {
        for x in data[y].Indices() {
            pos := (x, y)
            id := data[y][x]
            mut sidesSet := set[((int, int), (int, int))]{}
            region := dfs(id, pos, mut seen, mut sidesSet)
            area := region.Len()
            res += area * sidesSet.Len()
        }
    }
    printf("%d", res)
}

func part2() {
    mut res := 0
    mut seen := set[(int, int)]{}
    for y in data.Indices() {
        for x in data[y].Indices() {
            pos := (x, y)
            id := data[y][x]
            mut sidesSet := set[((int, int), (int, int))]{}
            region := dfs(id, pos, mut seen, mut sidesSet)
            mut sides := 0
            for (dirI, dir) in directions.Enumerated() {
                dirMod := dirI % 2 == 0
                dirPos := dir
                sidesArrDir := sidesSet.Filter({ $0.0 == dirPos }).Map({ $0.1 }).Sorted(by: {
                    if $0.0 == $1.0 && $0.1 == $1.1 {
                        return true
                    }
                    return if $0.0 == $1.0 { $0.1 < $1.1 } else { $0.0 < $1.0 }
                })
                
                mut groupsMap := map[int][](int, int){}
                for pos in sidesArrDir {
                    k := if dirMod { pos.0 } else { pos.1 }
                    groupsMap[k].Push(pos)
                }
                sides += groupsMap.Len()
                groups := groupsMap.Values()
                for group in groups {
                    for (el1, el2) in zip(group, group[1:]) {
                        diff := if dirMod { el2.1 - el1.1 } else { el2.0 - el1.0 }
                        if diff > 1 {
                            sides += 1
                        }
                    }
                }
            }
            res += region.Len() * sides
        }
    }
    printf("%d", res)
}

func main() {
    fileContent := string(os.ReadFile("examples/adventOfCode2024/day12/data.txt")!)
    data = fileContent.Lines().Map({ $0.Split("") })
    width = data[0].Len()
    height = data.Len()
    part1()
    part2()
}