package main

import "fmt"

type Value struct {
    mut Data f64
    mut Grad f64
    mut backward func()
    mut prev set[*Value]
    mut op string
}
func (v Value) String() string {
    return fmt.Sprintf("V(data:%v grad:%v)", v.Data, v.Grad)
}
func NewValue(data f64, children []*Value) *Value {
    return &Value {
        Data: data,
        backward: func() {},
        prev: Set(children),
    }
}
func NewValue1(data f64) *Value {
    return NewValue(data, []*Value{})
}
func (mut v *Value) + (mut other *Value) *Value {
    mut out := NewValue(v.Data + other.Data, []*Value{v, other})
    out.backward = func() {
        v.Grad += out.Grad
        other.Grad += out.Grad
    }
    return out
}
func (mut v *Value) * (mut other *Value) *Value {
    mut out := NewValue(v.Data * other.Data, []*Value{v, other})
    out.backward = func() {
        v.Grad += other.Data * out.Grad
        other.Grad += v.Data * out.Grad
    }
    return out
}
func (mut v *Value) ** (other int) *Value {
    mut out := NewValue(v.Data ** f64(other), []*Value{v})
    out.backward = func() {
        v.Grad += f64(other) * (f64(v.Data) ** f64(other-1)) * out.Grad
    }
    return out
}
func (mut v *Value) + (other f64) *Value {
    return v + NewValue1(other)
}
func (mut v *Value) * (other f64) *Value {
    return v * NewValue1(other)
}
func (mut v *Value) - (other *Value) *Value {
    return v + (-other)
}
func (mut v *Value) / (other *Value) *Value {
    return v * (other ** -1)
}
func (mut v *Value) / (other f64) *Value {
    return v * (other ** -1)
}
func (mut v *Value) __RQUO (other f64) *Value {
    return other * (v ** -1)
}
func (mut v *Value) __RADD (other f64) *Value {
    return v + other
}
func (mut v *Value) __RMUL (other f64) *Value {
    return v * other
}
func (mut v *Value) __NEG() *Value {
    return v * f64(-1)
}
func (mut v *Value) Relu() *Value {
    mut out := NewValue(if v.Data < f64(0.0) { f64(0.0) } else { v.Data }, []*Value{v})
    out.backward = func() {
        v.Grad += if out.Data > f64(0.0) { out.Grad } else { f64(0.0) }
    }
    return out
}

func buildTopo(v *Value, mut visited set[*Value], mut topo *[]*Value) {
    if visited.Insert(v) {
        for child in v.prev {
            buildTopo(child, mut visited, mut topo)
        }
        topo.Push(v)
    }
}

func (mut v *Value) Backward() {
    var mut topo []*Value
    mut visited := set[*Value]{}
    buildTopo(v, mut visited, &mut topo)
    v.Grad = 1.0
    for el in topo.Reversed() {
        el.backward()
    }
}

func main() {
    a := NewValue1(-4.0)
    b := NewValue1(2.0)
    mut c := a + b
    mut d := a * b + b**3
    c += c + f64(1)
    c += f64(1) + c + (-a)
    mut tmp1 := b + a
    d += d * f64(2) + tmp1.Relu()
    mut tmp2 := b - a
    d += f64(3) * d + tmp2.Relu()
    e := c - d
    f := e**2
    mut g := f / f64(2)
    g += f64(10) / f
    fmt.Printf("%.4f\n", g.Data) // prints 24.7041, the outcome of this forward pass
    g.Backward()
    fmt.Printf("%.4f\n", a.Grad) // prints 138.8338, i.e. the numerical value of dg/da
    fmt.Printf("%.4f\n", b.Grad) // prints 645.5773, i.e. the numerical value of dg/db
}